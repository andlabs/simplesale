// 24 march 2015
package main

import (
	"fmt"
	"os"
	"bufio"
	"strings"
	"text/template"
)

type Method struct {
	Ret		string
	Name	string
	Args		[]string
}

type Interface struct {
	IsRaw	bool
	Raw		string
	Name	string
	Methods	[]*Method
}

type File []*Interface

func die(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	fmt.Fprintf(os.Stderr, "\n")
	os.Exit(1)
}

func readfile(filename string) (f File) {
	var curiface *Interface

	infile, err := os.Open(filename)
	if err != nil {
		die("error opening %s: %v", filename, err)
	}
	defer infile.Close()

	scanner := bufio.NewScanner(infile)
	for scanner.Scan() {
		s := scanner.Text()
		if s == "" {
			continue
		}
		if s[0] == 'r' {		// raw line
			f = append(f, &Interface{
				IsRaw:	true,
				Raw:		s[1:],
			})
			continue
		}
		p := strings.Split(strings.TrimSpace(s), " ")
		if p[0][0] == '#' {	// comment
			continue
		}
		if p[0] == "i" {		// new interface
			if curiface != nil {
				f = append(f, curiface)
			}
			curiface = &Interface{
				Name:	p[1],
			}
			continue
		}
		if p[0] == "m" {		// method
			curiface.Methods = append(curiface.Methods, &Method{
				Ret:		p[1],
				Name:	p[2],
				Args:	p[3:],
			})
			continue
		}
		die("unknown line %q\n", s)
	}
	if err := scanner.Err(); err != nil {
		die("error reading %s: %v", filename, err)
	}

	if curiface != nil {
		f = append(f, curiface)
	}
	return f
}

const banner = "// generated by tools/iface2cdecl.go; do not edit"

// TODO break apart T* into T *
// TODO arguments
// TODO merge functions

func (m *Method) decl(curiface string, name string) string {
	s := m.Ret
	s += " "
	s += name
	s += "(" + curiface + " *this"
	i := 1
	for _, a := range m.Args {
		s += ", " + a + " " + fmt.Sprintf("arg%d", i)
		i++
	}
	s += ")"
	return s
}

func (m *Method) VtableDecl(curiface string) string {
	return m.decl(curiface, "(*" + m.Name + ")")
}

func (m *Method) GlobalDecl(curiface string) string {
	return m.decl(curiface, curiface + m.Name)
}

func (m *Method) ArgCallList() string {
	s := "this"
	i := 1
	for _, _ = range m.Args {
		s += fmt.Sprintf(", arg%d", i)
		i++
	}
	return s
}

const hfileTemplate = banner + `
{{range .}}
#define {{.Name}}Type ({{.Name}}_get_type())
#define {{.Name}}(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), {{.Name}}Type, {{.Name}}))
#define Is{{.Name}}(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), {{.Name}}Type))
#define Get{{.Name}}Interface(inst) (G_TYPE_INSTANCE_GET_INTERFACE((inst), {{.Name}}Type, {{.Name}}Interface))
typedef struct {{.Name}} {{.Name}};
typedef struct {{.Name}}Interface {{.Name}}Interface;
struct {{.Name}}Interface {
	GTypeInterface parent_iface;
{{$name := .Name}}{{range .Methods}}	{{.VtableDecl $name}};
{{end}}};
extern GType {{.Name}}_get_type(void);
extern void verify{{.Name}}Impl(char *, {{.Name}}Interface *);
{{$name := .Name}}{{range .Methods}}extern {{.GlobalDecl $name}};
{{end}}{{end}}`

func genhfile(f File, filename string) {
	of, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer of.Close()

	ifaces := make([]*Interface, 0, len(f))
	for _, i := range f {
		if !i.IsRaw {			// skip raw lines; they're just for the C file
			ifaces = append(ifaces, i)
		}
	}

	t := template.Must(template.New("hfile").Parse(hfileTemplate))
	err = t.Execute(of, ifaces)
	if err != nil {
		die("error generating .h file: %v", err)
	}
}

const cfileTemplate = banner + `
{{range .}}{{if .IsRaw}}{{.Raw}}
{{else}}
// {{.Name}}

G_DEFINE_INTERFACE({{.Name}}, {{.Name}}, G_TYPE_OBJECT)

{{$name := .Name}}{{range .Methods}}{{.GlobalDecl $name}}
{
	{{if ne .Ret "void"}}return {{end}}(*(Get{{$name}}Interface(this)->{{.Name}}))({{.ArgCallList}});
}

{{end}}static void {{.Name}}_default_init({{.Name}}Interface *iface)
{
}

void verify{{.Name}}Impl(char *typename, {{.Name}}Interface *iface)
{
{{$name := .Name}}{{range .Methods}}	if (iface->{{.Name}} == NULL)
		g_error("BUG: type %s missing implementation of {{$name}} method {{.Name}}()", typename);
{{end}}}
{{end}}{{end}}`

func gencfile(f File, filename string) {
	of, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer of.Close()

	t := template.Must(template.New("hfile").Parse(cfileTemplate))
	err = t.Execute(of, f)
	if err != nil {
		die("error generating .c file: %v", err)
	}
}

func main() {
	if len(os.Args) != 4 {
		die("usage: %s ifacefile type outfile", os.Args[0])
	}

	f := readfile(os.Args[1])
	outfile := os.Args[3]

	switch os.Args[2] {
	case "hfile":
		genhfile(f, outfile)
	case "cfile":
		gencfile(f, outfile)
	default:
		die("unknown output type %q", os.Args[2])
	}
}
