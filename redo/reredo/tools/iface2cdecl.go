// 24 march 2015
package main

import (
	"fmt"
	"os"
	"bufio"
	"strings"
	"text/template"
)

type Method struct {
	Ret			string
	Name		string
	ArgTypes		[]string
	ArgNames	[]string
	ArgsFull		[]string
}

type Interface struct {
	IsRaw	bool
	Raw		string
	Name	string
	Methods	[]*Method
}

type File []*Interface

func die(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	fmt.Fprintf(os.Stderr, "\n")
	os.Exit(1)
}

func (m *Method) loadargs(raw []string) {
	m.ArgTypes = make([]string, 0, len(raw) / 2)
	m.ArgNames = make([]string, 0, len(raw) / 2)
	m.ArgsFull = make([]string, 0, len(raw) / 2)
	for i := 0; i < len(raw); i += 2 {
		ty := raw[i]
		name := raw[i + 1]
		if ty[len(ty) - 1] == '*' {
			ty = ty[:len(ty) - 1] + " *"
			m.ArgsFull = append(m.ArgsFull, ty + name)
		} else {
			m.ArgsFull = append(m.ArgsFull, ty + " " + name)
		}
		m.ArgTypes = append(m.ArgTypes, ty)
		m.ArgNames = append(m.ArgNames, name)
	}
}

func readfile(filename string) (f File) {
	var curiface *Interface

	infile, err := os.Open(filename)
	if err != nil {
		die("error opening %s: %v", filename, err)
	}
	defer infile.Close()

	scanner := bufio.NewScanner(infile)
	for scanner.Scan() {
		s := scanner.Text()
		if s == "" {
			continue
		}
		if s[0] == 'r' {		// raw line
			f = append(f, &Interface{
				IsRaw:	true,
				Raw:		s[1:],
			})
			continue
		}
		p := strings.Split(strings.TrimSpace(s), " ")
		if p[0][0] == '#' {	// comment
			continue
		}
		if p[0] == "i" {		// new interface
			if curiface != nil {
				f = append(f, curiface)
			}
			curiface = &Interface{
				Name:	p[1],
			}
			continue
		}
		if p[0] == "m" {		// method
			m := &Method{
				Ret:		p[1],
				Name:	p[2],
			}
			m.loadargs(p[3:])
			curiface.Methods = append(curiface.Methods, m)
			continue
		}
		die("unknown line %q\n", s)
	}
	if err := scanner.Err(); err != nil {
		die("error reading %s: %v", filename, err)
	}

	if curiface != nil {
		f = append(f, curiface)
	}
	return f
}

const banner = "// generated by tools/iface2cdecl.go; do not edit"

func (m *Method) decl(curiface string, name string, args []string) string {
	s := m.Ret
	s += " "
	s += name
	s += "(" + curiface + " *this"
	for _, a := range args {
		s += ", " + a
	}
	s += ")"
	return s
}

func (m *Method) VtableDecl(curiface string) string {
	return m.decl(curiface, "(*" + m.Name + ")", m.ArgTypes)
}

func (m *Method) GlobalDecl(curiface string) string {
	return m.decl(curiface, curiface + m.Name, m.ArgTypes)
}

func (m *Method) GlobalDefn(curiface string) string {
	return m.decl(curiface, curiface + m.Name, m.ArgsFull)
}

// TODO split the for loop into its own function?
func (m *Method) ArgCallList() string {
	s := "this"
	for _, a := range m.ArgNames {
		s += ", " + a
	}
	return s
}

func ifacesOnly(f File) []*Interface {
	ifaces := make([]*Interface, 0, len(f))
	for _, i := range f {
		if !i.IsRaw {
			ifaces = append(ifaces, i)
		}
	}
	return ifaces
}

const hfileTemplate = banner + `
{{range .}}
#define {{.Name}}Type ({{.Name}}_get_type())
#define {{.Name}}(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), {{.Name}}Type, {{.Name}}))
#define Is{{.Name}}(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), {{.Name}}Type))
#define Get{{.Name}}Interface(inst) (G_TYPE_INSTANCE_GET_INTERFACE((inst), {{.Name}}Type, {{.Name}}Interface))
typedef struct {{.Name}} {{.Name}};
typedef struct {{.Name}}Interface {{.Name}}Interface;
struct {{.Name}}Interface {
	GTypeInterface parent_iface;
{{$name := .Name}}{{range .Methods}}	{{.VtableDecl $name}};
{{end}}};
extern GType {{.Name}}_get_type(void);
extern void verify{{.Name}}Impl(char *, {{.Name}}Interface *);
{{$name := .Name}}{{range .Methods}}extern {{.GlobalDecl $name}};
{{end}}{{end}}`

func genhfile(f File, filename string) {
	of, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer of.Close()

	t := template.Must(template.New("hfile").Parse(hfileTemplate))
	err = t.Execute(of, ifacesOnly(f))
	if err != nil {
		die("error generating .h file: %v", err)
	}
}

const cfileTemplate = banner + `
{{range .}}{{if .IsRaw}}{{.Raw}}
{{else}}
// {{.Name}}

G_DEFINE_INTERFACE({{.Name}}, {{.Name}}, G_TYPE_OBJECT)

{{$name := .Name}}{{range .Methods}}{{.GlobalDefn $name}}
{
	{{if ne .Ret "void"}}return {{end}}(*(Get{{$name}}Interface(this)->{{.Name}}))({{.ArgCallList}});
}

{{end}}static void {{.Name}}_default_init({{.Name}}Interface *iface)
{
}

void verify{{.Name}}Impl(char *typename, {{.Name}}Interface *iface)
{
{{$name := .Name}}{{range .Methods}}	if (iface->{{.Name}} == NULL)
		g_error("BUG: type %s missing implementation of {{$name}} method {{.Name}}()", typename);
{{end}}}
{{end}}{{end}}`

func gencfile(f File, filename string) {
	of, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer of.Close()

	t := template.Must(template.New("cfile").Parse(cfileTemplate))
	err = t.Execute(of, f)
	if err != nil {
		die("error generating .c file: %v", err)
	}
}

const stubTemplate = `{{$tn := .TypeName}}struct {{$tn}}Priv {
};

G_DEFINE_TYPE_WITH_CODE({{$tn}}, {{$tn}}, G_TYPE_OBJECT,{{range .Interfaces}}
	G_IMPLEMENT_INTERFACE({{.Name}}Type, {{$tn}}_{{.Name}}_init){{end}})

static void {{$tn}}_init({{$tn}} *this)
{
	this->priv = G_TYPE_INSTANCE_GET_PRIVATE(this, {{$tn}}Type, struct {{$tn}}Priv);
}

static void {{$tn}}_dispose(GObject *obj)
{
	G_OBJECT_CLASS({{$tn}}_parent_class)->dispose(obj);
}

static void {{$tn}}_finalize(GObject *obj)
{
	G_OBJECT_CLASS({{$tn}}_parent_class)->finalize(obj);
}
{{range .Interfaces}}{{range .Methods}}
static {{.GlobalDefn $tn}}
{
}
{{end}}
static void {{$tn}}_{{.Name}}_init({{.Name}}Interface *iface)
{
{{range .Methods}}	iface->{{.Name}} = {{$tn}}{{.Name}};
{{end}}	verify{{.Name}}Impl("{{$tn}}", iface);
}
{{end}}
static void {{$tn}}_class_init({{$tn}}Class *class)
{
	g_type_class_add_private(class, sizeof (struct {{$tn}}Priv));

	G_OBJECT_CLASS(class)->dispose = {{$tn}}_dispose;
	G_OBJECT_CLASS(class)->finalize = {{$tn}}_finalize;
}
`

func genstub(f File, typename string, filename string) {
	of, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer of.Close()

	t := template.Must(template.New("stub").Parse(stubTemplate))
	err = t.Execute(of, struct {
		TypeName	string
		Interfaces		[]*Interface
	}{
		TypeName:	typename,
		Interfaces:	ifacesOnly(f),
	})
	if err != nil {
		die("error generating .c file: %v", err)
	}
}

func main() {
	if len(os.Args) != 4 {
		die("usage: %s ifacefile type outfile", os.Args[0])
	}

	f := readfile(os.Args[1])
	outfile := os.Args[3]

	s := os.Args[2]
	switch {
	case s == "hfile":
		genhfile(f, outfile)
	case s == "cfile":
		gencfile(f, outfile)
	case strings.HasPrefix(s, "stub"):
		s = s[4:]
		genstub(f, s, outfile)
	default:
		die("unknown output type %q", s)
	}
}
