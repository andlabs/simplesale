// 24 march 2015
package main

import (
	"fmt"
	"os"
	"bufio"
	"strings"
)

type method struct {
	Ret		string
	Name	string
	Args		[]string
}

type ifaceentry struct {
	Raw		string
	Name	string
	Method	method
}

type iface []ifaceentry

func die(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	fmt.Fprintf(os.Stderr, "\n")
	os.Exit(1)
}

func readiface(filename string) (i iface) {
	f, err := os.Open(filename)
	if err != nil {
		die("error opening %s: %v", filename, err)
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		s := scanner.Text()
		if s == "" {
			continue
		}
		if s[0] == 'r' {		// raw line
			i = append(i, ifaceentry{
				Raw:		s[1:],
			})
			continue
		}
		p := strings.Split(strings.TrimSpace(s), " ")
		if p[0][0] == '#' {	// comment
			continue
		}
		if p[0] == "i" {		// new interface
			i = append(i, ifaceentry{
				Name:	p[1],
			})
			continue
		}
		if p[0] == "m" {		// method
			i = append(i, ifaceentry{
				Method:	method{
					Ret:		p[1],
					Name:	p[2],
					Args:	p[3:],
				},
			})
			continue
		}
		die("unknown line %q\n", s)
	}
	if err := scanner.Err(); err != nil {
		die("error reading %s: %v", filename, err)
	}

	return i
}

const banner = "// generated by tools/iface2cdecl.go; do not edit"

// TODO break apart T* into T *
// TODO arguments
// TODO merge functions

func (m method) decl(curiface string, name string) string {
	s := m.Ret
	s += " "
	s += name
	s += "(" + curiface + " *this"
	i := 1
	for _, a := range m.Args {
		s += ", " + a + " " + fmt.Sprintf("arg%d", i)
		i++
	}
	s += ")"
	return s
}

func (m method) vtabledecl(curiface string) string {
	return m.decl(curiface, "(*" + m.Name + ")")
}

func (m method) globaldecl(curiface string) string {
	return m.decl(curiface, curiface + m.Name)
}

func genhfile(i iface, filename string) {
	f, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer f.Close()

	// TODO error checking

	curiface := ""
	curmethods := []method(nil)
	startiface := func() {
		fmt.Fprintf(f, "#define %sType (%s_get_type())\n", curiface, curiface)
		fmt.Fprintf(f, "#define %s(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), %sType, %s))\n", curiface, curiface, curiface)
		fmt.Fprintf(f, "#define Is%s(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), %sType))\n", curiface, curiface)
		fmt.Fprintf(f, "#define Get%sInterface(inst) (G_TYPE_INSTANCE_GET_INTERFACE((inst), %sType, %sInterface))\n", curiface, curiface, curiface)
		fmt.Fprintf(f, "typedef struct %s %s;\n", curiface, curiface)
		fmt.Fprintf(f, "typedef struct %sInterface %sInterface;\n", curiface, curiface);
		fmt.Fprintf(f, "struct %sInterface {\n", curiface);
		fmt.Fprintf(f, "\tGTypeInterface parent_iface;\n");
		// TODO add a newline here?
	}
	endiface := func() {
		if curiface == "" {
			return
		}
		fmt.Fprintf(f, "};\n")
		fmt.Fprintf(f, "extern GType %s_get_type(void);\n", curiface)
		fmt.Fprintf(f, "extern void verify%sImpl(char *, %sInterface *);\n", curiface, curiface)
		for _, m := range curmethods {
			fmt.Fprintf(f, "extern %s;\n", m.globaldecl(curiface))
		}
		fmt.Fprintf(f, "\n")
		curiface = ""
		curmethods = nil
	}

	// TODO error checking
	fmt.Fprintf(f, "%s\n", banner)
	for _, e := range i {
		if e.Raw != "" {		// raw line
			continue
		}
		if e.Name != "" {	// new interface
			endiface()
			curiface = e.Name
			startiface()
			continue
		}
		// must be a method
		curmethods = append(curmethods, e.Method)
		fmt.Fprintf(f, "\t%s;\n", e.Method.vtabledecl(curiface))
	}
	endiface()
}

func gencfile(i iface, filename string) {
	f, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer f.Close()

	// TODO error checking

	curiface := ""
	curmethods := []method(nil)
	startiface := func() {
		fmt.Fprintf(f, "G_DEFINE_INTERFACE(%s, %s, G_TYPE_OBJECT)\n", curiface, curiface)
	}
	endiface := func() {
		if curiface == "" {
			return
		}
		fmt.Fprintf(f, "static void %s_default_init(%sInterface *iface)\n", curiface, curiface)
		fmt.Fprintf(f, "{\n")
		fmt.Fprintf(f, "}\n")
		fmt.Fprintf(f, "void verify%sImpl(char *typename, %sInterface *iface)\n", curiface, curiface)
		fmt.Fprintf(f, "{\n")
		for _, m := range curmethods {
			fmt.Fprintf(f, "\tif (iface->%s == NULL)\n", m.Name)
			fmt.Fprintf(f, "\t\tg_error(\"BUG: type %%s missing implementation of %s method %s\", typename);\n", curiface, m.Name)
		}
		fmt.Fprintf(f, "}\n")
		fmt.Fprintf(f, "\n")
		curiface = ""
		curmethods = nil
	}

	// TODO error checking
	fmt.Fprintf(f, "%s\n", banner)
	for _, e := range i {
		if e.Raw != "" {		// raw line
			continue
		}
		if e.Name != "" {	// new interface
			endiface()
			curiface = e.Name
			startiface()
			continue
		}
		// must be a method
		curmethods = append(curmethods, e.Method)
		fmt.Fprintf(f, "%s\n", e.Method.globaldecl(curiface))
		fmt.Fprintf(f, "{\n")
		fmt.Fprintf(f, "\t")
		if e.Method.Ret != "void" {
			fmt.Fprintf(f, "return ")
		}
		k := "(*(Get" + curiface + "Interface(this)->" + e.Method.Name + "))"
		fmt.Fprintf(f, "%s(this", k)
		n := 1
		for _, _ = range e.Method.Args {
			fmt.Fprintf(f, ", arg%d", n)
			n++
		}
		fmt.Fprintf(f, ");\n")
		fmt.Fprintf(f, "}\n")
	}
	endiface()
}

func main() {
	if len(os.Args) != 4 {
		die("usage: %s ifacefile type outfile", os.Args[0])
	}

	iface := readiface(os.Args[1])
	outfile := os.Args[3]

	switch os.Args[2] {
	case "hfile":
		genhfile(iface, outfile)
	case "cfile":
		gencfile(iface, outfile)
	default:
		die("unknown output type %q", os.Args[2])
	}
}
