// 24 march 2015
package main

import (
	"fmt"
	"os"
	"bufio"
	"strings"
	"text/template"
)

type Method struct {
	Ret		string
	Name	string
	Args		[]string
}

type Interface struct {
	IsRaw	bool
	Raw		string
	Name	string
	Methods	[]*Method
}

type File []*Interface

func die(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	fmt.Fprintf(os.Stderr, "\n")
	os.Exit(1)
}

func readfile(filename string) (f File) {
	var curiface *Interface

	infile, err := os.Open(filename)
	if err != nil {
		die("error opening %s: %v", filename, err)
	}
	defer infile.Close()

	scanner := bufio.NewScanner(infile)
	for scanner.Scan() {
		s := scanner.Text()
		if s == "" {
			continue
		}
		if s[0] == 'r' {		// raw line
			f = append(f, &Interface{
				IsRaw:	true,
				Raw:		s[1:],
			})
			continue
		}
		p := strings.Split(strings.TrimSpace(s), " ")
		if p[0][0] == '#' {	// comment
			continue
		}
		if p[0] == "i" {		// new interface
			if curiface != nil {
				f = append(f, curiface)
			}
			curiface = &Interface{
				Name:	p[1],
			}
			continue
		}
		if p[0] == "m" {		// method
			curiface.Methods = append(curiface.Methods, &Method{
				Ret:		p[1],
				Name:	p[2],
				Args:	p[3:],
			})
			continue
		}
		die("unknown line %q\n", s)
	}
	if err := scanner.Err(); err != nil {
		die("error reading %s: %v", filename, err)
	}

	if curiface != nil {
		f = append(f, curiface)
	}
	return f
}

const banner = "// generated by tools/iface2cdecl.go; do not edit"

// TODO break apart T* into T *
// TODO arguments
// TODO merge functions

func (m *Method) decl(curiface string, name string) string {
	s := m.Ret
	s += " "
	s += name
	s += "(" + curiface + " *this"
	i := 1
	for _, a := range m.Args {
		s += ", " + a + " " + fmt.Sprintf("arg%d", i)
		i++
	}
	s += ")"
	return s
}

func (m *Method) VtableDecl(curiface string) string {
	return m.decl(curiface, "(*" + m.Name + ")")
}

func (m *Method) GlobalDecl(curiface string) string {
	return m.decl(curiface, curiface + m.Name)
}

const hfileTemplate = banner + `
{{range .}}
#define {{.Name}}Type ({{.Name}}_get_type())
#define {{.Name}}(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), {{.Name}}Type, {{.Name}}))
#define Is{{.Name}}(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), {{.Name}}Type))
#define Get{{.Name}}Interface(inst) (G_TYPE_INSTANCE_GET_INTERFACE((inst), {{.Name}}Type, {{.Name}}Interface))
typedef struct {{.Name}} {{.Name}};
typedef struct {{.Name}}Interface {{.Name}}Interface;
struct {{.Name}}Interface {
	GTypeInterface parent_iface;
{{$name := .Name}}{{range .Methods}}	{{.VtableDecl $name}};
{{end}}};
extern GType {{.Name}}_get_type(void);
extern void verify{{.Name}}Impl(char *, {{.Name}}Interface *);
{{$name := .Name}}{{range .Methods}}extern {{.GlobalDecl $name}};
{{end}}{{end}}`

func genhfile(f File, filename string) {
	of, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer of.Close()

	ifaces := make([]*Interface, 0, len(f))
	for _, i := range f {
		if !i.IsRaw {			// skip raw lines; they're just for the C file
			ifaces = append(ifaces, i)
		}
	}

	t := template.Must(template.New("hfile").Parse(hfileTemplate))
	err = t.Execute(of, ifaces)
	if err != nil {
		die("error generating .h file: %v", err)
	}
}

/*
func gencfile(i iface, filename string) {
	f, err := os.Create(filename)
	if err != nil {
		die("error creating %s: %v", filename, err)
	}
	defer f.Close()

	// TODO error checking

	curiface := ""
	curmethods := []method(nil)
	startiface := func() {
		fmt.Fprintf(f, "G_DEFINE_INTERFACE(%s, %s, G_TYPE_OBJECT)\n", curiface, curiface)
	}
	endiface := func() {
		if curiface == "" {
			return
		}
		fmt.Fprintf(f, "static void %s_default_init(%sInterface *iface)\n", curiface, curiface)
		fmt.Fprintf(f, "{\n")
		fmt.Fprintf(f, "}\n")
		fmt.Fprintf(f, "void verify%sImpl(char *typename, %sInterface *iface)\n", curiface, curiface)
		fmt.Fprintf(f, "{\n")
		for _, m := range curmethods {
			fmt.Fprintf(f, "\tif (iface->%s == NULL)\n", m.Name)
			fmt.Fprintf(f, "\t\tg_error(\"BUG: type %%s missing implementation of %s method %s\", typename);\n", curiface, m.Name)
		}
		fmt.Fprintf(f, "}\n")
		fmt.Fprintf(f, "\n")
		curiface = ""
		curmethods = nil
	}

	// TODO error checking
	fmt.Fprintf(f, "%s\n", banner)
	for _, e := range i {
		if e.Raw != "" {		// raw line
			continue
		}
		if e.Name != "" {	// new interface
			endiface()
			curiface = e.Name
			startiface()
			continue
		}
		// must be a method
		curmethods = append(curmethods, e.Method)
		fmt.Fprintf(f, "%s\n", e.Method.globaldecl(curiface))
		fmt.Fprintf(f, "{\n")
		fmt.Fprintf(f, "\t")
		if e.Method.Ret != "void" {
			fmt.Fprintf(f, "return ")
		}
		k := "(*(Get" + curiface + "Interface(this)->" + e.Method.Name + "))"
		fmt.Fprintf(f, "%s(this", k)
		n := 1
		for _, _ = range e.Method.Args {
			fmt.Fprintf(f, ", arg%d", n)
			n++
		}
		fmt.Fprintf(f, ");\n")
		fmt.Fprintf(f, "}\n")
	}
	endiface()
}
*/

func main() {
	if len(os.Args) != 4 {
		die("usage: %s ifacefile type outfile", os.Args[0])
	}

	f := readfile(os.Args[1])
	outfile := os.Args[3]

	switch os.Args[2] {
	case "hfile":
		genhfile(f, outfile)
	case "cfile":
//		gencfile(f, outfile)
	default:
		die("unknown output type %q", os.Args[2])
	}
}
